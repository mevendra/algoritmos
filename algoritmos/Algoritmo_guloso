Algoritmo Guloso

Grafo(Vertices, Arestas), n = Numero de Vertices, a = Maior grau de saida, c = Tamanho do maior caminho entre 2 vertices

Fila fila
for(Vertice v: Vertices)	//Executa n vezes
{	
	v.lista_cores.adicionar(v.cor)
	if (v.eh_folha) {
		fila.adicionar(v)
	}
}

while(!fila.vazio())	//Para cada Vertice pode executar a vezes(Executa de acordo com o numero de filhos, no maximo n*a vezes)
{
	Vertice v = fila.remover_primeiro()
	for(Vertice pai: v.pais())	//Executa 2x
	{
		fila.adicionar(pai)	//constante(adiciona no final)
	}

	for(Vertice filho: v.filhos())	//Executa no maximo a vezes
	{
		if (filho.lista_cores.tamanho >= v.lista_cores.tamanho) {	// >= Pq a lista do filho pode ou nao conter a cor do pai, cor que ja esta adicionada na lista do pai
			v.lista_cores = filho.lista_cores.copiar_lista()	//Maximo = c (Se todos os vertices do caminho tiverem cores diferentes)
			v.lista_cores.adicionar(v.cor)	//Maximo = c (Percorre a lista para verificar se v.cor esta nela)
		}
	}
}

Complexidade
Tempo: 2n + n * a * (a * (1 + 2 * c) + 3) //Considerando complexidade de operar sobre estruturas de dados

Tamanho: n * c //Cada vertice com uma lista de no maximo c elementos(c = n em um grafo conexo)
