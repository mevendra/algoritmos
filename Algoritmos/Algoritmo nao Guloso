Algoritmo nao Guloso
Grafo(Vertices, Arestas), n = Numero de Vertices, a = Maior grau de saida, c = Tamanho do maior caminho entre 2 vertices

Fila fila
for(Vertice v: Vertices)	//Executa n vezes
{
	if (v.eh_folha) {
		v.lista_cores.adicionar(nova_lista(v.cor))
		fila.adicionar(v);
	}
}

while(!fila.vazio())	//Executa no maximo n * a vezes, mas n * (a - 1) vezes sai da execução no primeiro for
{
	Vertice v = fila.remover_primeiro()

	if (v.ja_avaliado) {
		continuar while
	}

	for(Vertice filho: v.filhos())	//Maximo a vezes
	{
		if (filho.ja_avaliado = false) {
			fila.adicionar(v)
			continuar while
		}
	}

	//Apartir daqui executa n vezes
	for(Vertice pai: v.pais())	//Maximo 2
	{
		for(Lista lista: v.lista_cores)	//Maximo a vezes
		{
			if (!pai.lista_cores.contem(lista + pai.cor)) {	//Percorre por no maximo a elementos, cada elemento com no maximo c de tamanho
				pai.lista_cores.adicionar(lista + pai.cor)
			}
		}
		fila.adicionar(pai)
	}

	v.ja_avaliado = true
}

Complexidade
Tempo: n + (4 * n * a) + (n * (2 * (a * (a * c + 1)) + 1))

Tamanho: a * n * c	//Cada vertice com a listas de tamanho maximo n